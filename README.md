## Распределенные данные от Алекса Петрова

Изначально я планировал выкладывать конспекты по каждой главе у себя в tg канале, но вскоре понял, что телега - не лучшее место для конспектов по книгам, поэтому я перенес его сюда. 
Сказать, что это конспект в привычном понимании этого слова было бы неправильным, я бы назвал это смесью конспекта с щепотками собственного мнения под соусом странной манеры письма. 

### Глава 2. Введение в B-деревья
Эта глава посвящена теме, с которой я познакомился еще будучи студентом колледжа, и к которой я возвращаюсь по сей день - это B-Tree. Да, та самая структура данных, которую умные люди в области создания этих сложных СХД взяли за основу построения реляционных баз данных типа PostgreSQL или MySQL. Для начала хорошо бы понять, а почему вообще упарываться с такой сложной структурой данных, когда можно использовать стандартное двоичное дерево. Ну да, может быть проблема с балансированием таких деревьев, но есть же сбалансированные варианты типа AVL, Red-Black Tree и т.д. Секрет кроется в возможностях сегодняшних жестких дисков и SSD. Если не знаете, как устроен диск, то вкратце скажу, что состоит он из движущейся головки, которая считывает информацию с пластин. Причем, головка читает данные последовательно и читает она эти данные секторами размером от 512Б до 4КБ - не побайтово. Аналогия с механизмом выделения памяти в ОС, где память отдается приложению в виде страниц фиксированного размера. Т.е чтобы прочесть какие-либо данные, должно произойти позиционирование головки, что является достаточно затратной операцией, а далее наступает процесс последовательного чтения, что происходит достаточно быстро. SSD же устроены несколько иначе: есть ячейки памяти, которые объединяются в строки (обычно от 32 до 64 ячеек на строку), строки объединяются в массивы, массивы - в страницы, а страницы - в блоки. Блоки объединяются в пластины, а пластины уже образуют кристалл. Причем, размер ячейки памяти зависит от используемой технологии. Соответственно, размер одной страницы может варьироваться от 2 до 16КБ. В SSD минимальной единицей, которую можно прочитать или записать, является страница. Но стирание данных осуществляется поблочно, этим занимается отдельный компонент внутри SSD, называемый FTL (Flash Translation Layer). Но самое главное, что в отличие от тех же жестких дисков, с произвольным вводом-выводом у SSD все гораздо лучше. На этом этапе вы, возможно, задаете себе вопрос: "Ну и зачем мне это щас нужно было", ну а я отвечу, что благодаря этой инфе теперь можно подобрать структуру данных, которая обладает следующими свойствами: 

A. У структуры данных высокая степень ветвления (т.е возможность для одного узла иметь большое кол-во потомков), таким образом можно было бы обеспечить лучшую локальность соседних ключей (держать соседние ключи ближе друг к другу).\
Б. Структура данных не предусматривает наличие большой высоты, что сокращает количество операций дискового поиска во время обхода. 

Что ж, ну и умные люди по имени Байер и МкКрейт в 1972 и создали такую структуру данных как B-Tree. Вообще если хотите на интуитивном уровне понять, как она работает, то лучше всего посмотреть видео. Я читал достаточно много литературы (сюда входят и статьи), где описывают принцип ее работы, но ничего простого не нашел. А лучше всего посмотреть видео, а потом почитать статьи. Ну и нет ничего лучше идеи реализовать это на каком-нибудь ЯП. 
Для начала посоветую вот это [видео](https://www.youtube.com/watch?v=K1a2Bk8NrYQ).  
Есть еще вот такой [сайт](https://www.cs.usfca.edu/~galles/visualization/BTree.html), где можно интерактивно изучить принцип работы разных структур данных, в том числе и B-Tree. 

### Глава 3. Форматы файлов
Новая глава - новый пост. Сегодня поговорю о способе организации данных на диске, а именно о том, как представить узлы B-Tree на каком-либо дисковом носителе. Во-первых, нужно сказать, что для простоты разработчики СУБД решили выделять на один узел дерева одну страницу. Например, в оригинальной статье с описанием B-Tree описывался простейший способ организации этих страниц для записи данных, где это выглядит как-то вот так

| p0 | k1 | v1 | p1 | k2 | v2 | p2| .... |kn| |vn| |pn| 
где:

p - указатель на дочерние страницы
k - ключ
v - значение

Но такой подход обладает недостатками. 
1. Если новая запись добавляется не справа, то возникает необходимость перемешивать элементы
2. Данный способ подходит только для данных фиксированного размера
3. Если хранить в таком виде данные переменного размера, возникает проблема с фрагментацией, т.е когда у нас есть много свободных кусков разного размера, появившихся в результате освобождения ненужных ячеек. При такой организации достаточно сложно дефрагментировать память. 

Для устранения этих проблем была придумана структура слотированных страниц (slotted page). Выглядит она как-то так 

<img width="755" alt="pic" src="https://github.com/user-attachments/assets/1bbbce6c-12c1-495b-a415-41b4d33460c7">

В данной схеме у нас есть: 

Заголовок, содержащий в себе метаинформацию, типа id страницы, количество свободного места, указатели на начало свободного и конец свободной памяти, различные флаги, тип узла (ROOT, INTERIOR, LEAF).

Указатели, указывающие на ячейки. Причем, указатели отсортированы для возможности двоичного поиска

Ну и сами ячейки, хранящие пары ключ/запись. 

Такая структура позволяет достаточно гибко как вставлять, так и удалять данные. В случае удаления указатель на ячейку может быть помечен как "not used", ну а на странице может быть выставлен флаг CAN_COMPACT. Через какое-то время гарбедж коллектор просто скомпактит страницу, освободив место для будущих вставок. 

Вот тут более подробно рассказывается про слотированные страницы 
https://siemens.blog/posts/database-page-layout/
Еще и код есть, что вообще неплохо. 

### Глава 4. Реализация B-деревьев в БД
Продолжаем говорить о B-деревьях. Это уже 3 глава о них, да. Вот такие они сложные и важные. Во-первых, надо повторить, что каждому узлу в дереве соответствует одна страница. Одна такая страница содержит заголовок, отсортированные смещения (или указатели на ячейки) и сами ячейки, содержащие пары ключ/запись. Каждый файл, содержащий данные, начинается с магического числа (Magic number). Обычно это набор каких-то байтов, которые помогают понять, с каким файлом мы имеем дело.
 
**Линки между узлами**
Представим дерево с одним корневым узлом и 2 дочерними узлами child1 и child2. Путь от одного дочернего узла к другому дочернему узлу содержит посещение корневого узла. Некоторые реализации избегают последнего путем создания линков между одноуровневыми узлами. Учитывая, что все ключи на уровне отсортированы, это достаточно хороший подход, экономящий время поиска. Минусом такого подхода является экстра оверхед при апдейте линков при разделении и слиянии. 

**Крайние правые указатели и высокие узлы ключа**
Дисклеймер: здесь я буду описывать подходы, значение которых я пока совсем не догоняю, но для чего-то разработчики СУБД их применяют. 
Подход крайнего правого указателя подразумевает хранение крайнего правого указателя в узле в заголовке страницы. Этот указатель не связан с каким-либо ключом. 
Подход с высоким узлом ключа подразумевает добавление еще одного ключа, который задает верхнюю границу в узле. Данный ключ является парой для крайнего правого указателя. 
Оба подхода используются в СУБД sqlite и PostgreSQL соответственно. 

**Страницы переполнения**
Об этом я должен был, возможно, рассказать в предыдущем посте, но я скинул ссылку на статью, которая содержала в себе описание этого механизма. Лучше всего этот процесс можно понять, представив себе ситуацию. Представим, что в один из столбцов базы вы пишете целое полотно текста, полотно это настолько большое, что место в странице заканчивается уже после после половины записанного текста. В таком случае создается доп. страница переполнения, на которую ссылается страница с началом вашего полотна. Таких страниц может быть несколько в зависимости от ваших записей. Все они представляют собой связанный список. 

**Распространение операций разделения и слияния**
Как вы уже знаете, узлы в B-Tree могут делиться и склеиваться. В таком случае нам нужно распространить эти операции в рамках всего дерева, т.е переназначить указатели. Для нахождения целевого узла нам необходимо проделать путь до корня дерева, а затем спуститься обратно рекурсивно вниз. 

**Навигационная цепочка**
Вместо того чтобы хранить и поддерживать указатели на родительские узлы, можно хранить путь к узлу в какой-нибудь структуре данных, ну и в случае каскадного разделения или слияния можно пройти 

**Перебалансировка**
Чтобы улучшить распределение нагрузки, некоторые реализации производят операцию перебалансировки, т.е переносят ключи и более загруженных узлов в менее загруженные узлы. 

**Добавление только справа**
Многие СУБД используют в качестве первичного ключа авто-инкрементирующиеся значения. Это открывает возможность для оптимизации. Если вставляемый ключ больше первого ключа в крайнем правом узле, то мы можем положить ключ в закешированную крайнюю правую страницу, исключая необходимость обхода дерева в поисках нужного места. 

**Сжатие**
Еще один необходимый элемент для эффективного хранения данных. С ростом количества данных растут и требования к объему носителей. Чтобы замедлить этот процесс, разработчики прибегают к сжатию. Алгоритмов сжатия достаточно много, но при выборе нам нужно обращать внимание на такие параметры как степень сжатия, производительность и издержки памяти.  Например, Clickhouse по дефолту использует zstd. После выбора алгоритма встает вопрос о том, что сжимать. Сжимать целый файл - как-то не комильфо. Это означает, что при каждом доступе к какой-либо из страниц нам придется вернуть весь файл в начальное состояние, достать нужную страницу и т.д. Поэтому появилась идея сжимать данные постранично. 

**Очистка и обслуживание**
Записи в базе периодически удаляются. Конечно же, СУБД не удаляет их сразу, так как это очень дорого. Вместо этого данные помечаются нулями. Точнее, на эти данные нет никаких указателей, соответственно их можно считать мусором. Для этого в ряде СУБД существует фоновый процесс чистки, своего рода гарбэдж коллектор, который эту работу и делает. В качестве доп. чтения привожу 2 полезные статьи:
https://www.lucavall.in/blog/how-databases-store-and-retrieve-data-with-b-trees
https://fly.io/blog/sqlite-internals-btree

P.S 
Я все больше склоняюсь к тому, что на чтение одной главы этой книги нужно уделять неделю, ибо полностью понять все за сутки без наличия каких-либо знаний по проектированию СХД достаточно проблематично.

